---
title: "Flow cytometry data analysis"
author: "Guilherme Marcelino Viana de Siqueira and Mar√≠a-Eugenia Guazzaroni"
date: "November, 2022"
output:
  html_document:
    css: css/style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## About this analysis

This analysis depends on the `data/flow_cytometry` directory found in the root directory for this project. In each experiment, cultures of *E. coli* DH10B and *P. putida* KT2440 were grown for four hours with agitation. After this, the samples were placed in ice until being passed through the BD FACS Canto II flow cytometer. For each sample, a .fcs file was generated by the machine. Our analysis workflow majorly relies on the flowCore and flowStats packages, with additional packages (mostly from the tidyverse) being used for data visualization and summary.

## 0. Setting up the analysis

We start by sourcing the utils.R script. This is a custom script that defines several functions for importing and processing data that will grant us flexibility in the analysis while keeping this document fairly concise.

```{r results='hide', error=FALSE, warning=FALSE, message=FALSE}
source("../utils.R")
```

## 1. Importing data

The first step is loading the cytometry data into R. For this, we will use the importCytometry() function that is defined in the utils.R script. This function reads a directory containing .fcs file(s) and returns a list containing a flowSet object for all .fcs found, their file names, and metadata information associated with them

```{r message=FALSE}
# for E. coli
coli <- importCytometry("../data/flow_cytometry/Ecoli/")

# for P. putida
putida <- importCytometry("../data/flow_cytometry/Pputida/")
```

## 2. Gating and subsetting the data

Once we successfully imported the flow cytometry raw data in R, we will define manual gates for filtering high-quality events. As an example, we will define gates for the replicate R3 of *P. putida* and *E. coli*.

*Observation: Please note that due to our data structure, the gating we apply to our flowSet will be applied to all replicates, which may be suboptimal for some cases (e.g. P. putida R2, which was recorded at a lower voltage) - we recommend the definition of new gates for these edge cases.*

For this step, we must define a **polygon**, set it as a **gate**, **filter** the data based on the polygon, then **subset** it using common flowCore functions

```{r}
# for P. putida:
putida_poly <- bind_cols("FSC-A" = c(10^2.65, 10^3.25, 10^4.6, 10^4.45), "FSC-H" = c(10^3, 10^2.95, 10^4.1, 10^4.375))
putida_gate <- flowCore::polygonGate(putida_poly, filterId = "putida_poly")
putida_filter <- flowCore::filter(putida$flowSet, putida_gate)
putida_P1 <- Subset(putida$flowSet, putida_filter)

# for E. coli:
coli_poly <- bind_cols("FSC-A" = c(10^2.65, 10^3.45, 10^4.8, 10^4.65), "FSC-H" = c(10^3, 10^2.95, 10^4.375, 10^4.6))
coli_gate <- flowCore::polygonGate(coli_poly, filterId = "coli_poly")
coli_filter <- flowCore::filter(coli$flowSet, coli_gate)
coli_P1 <- Subset(coli$flowSet, coli_filter)

```

After this, the putida_P1 and coli_P1 variables hold the events contained within the gate. At the moment our data is contained as a `flowSet` object. We will use the `cyto2tibble()` custom function to retrieve this information as a more manageable tibble so that we can explore different aspects of it.

```{r warning=FALSE, message=FALSE}

# accessing data as tibbles

# the original data
coli_tibble <- cyto2tibble(fs = coli$flowSet, names = coli$names, metadata = coli$metadata)
putida_tibble <- cyto2tibble(fs = putida$flowSet, names = putida$names, metadata = putida$metadata)

# the subsetted data - after gating
coliSubset_tibble <- cyto2tibble(fs = coli_P1, names = coli$names, metadata = coli$metadata)
putidaSubset_tibble <- cyto2tibble(fs = putida_P1, names = putida$names, metadata = putida$metadata)

```

To better understand the effects of this transformation, we can obtain the number of cases that are contained within our defined gate polygon with the custom function `calcGated()` and then plot it alongside the original data tibble with the custom function `plotGate()`.

First for _P. putida_:

```{r  fig.align='center', fig.width=9}

# calculating gating metrics
putidaMetrics <- calcGated(putida_tibble, putidaSubset_tibble) %>% left_join(putida$metadata)

# visualizing the gate
plotGate(data = putida_tibble,
         polygon = putida_poly,
         metrics = putidaMetrics,
         replicate_choice = "R3")

```
And for _E. coli_:

```{r  fig.align='center', fig.width=9}

# calculating gating metrics
coliMetrics <- calcGated(coli_tibble, coliSubset_tibble) %>% left_join(coli$metadata)

# visualizing the gate
plotGate(data = coli_tibble,
         polygon = coli_poly,
         metrics = coliMetrics,
         replicate_choice = "R3")

```

## 2. Visualizing the fluorescence profiles of different samples

Now that our data has been processed, we may proceed to the final step, which is measuring the fluorescence in the microbial cells carrying different versions of the plasmids under investigation. Fluorescence was recorded in the FITC channel of the cytometer, and is expressed with arbitrary units. We arbitrarily use 10^2 A.U. as a threshold for defining fluorescent/non-fluorescent cells and calculating their relative proportions. Here, we use the custom function `distributionPlot()` to autiomatically generate figures like those found in the manuscript.  

```{r message=FALSE, warning=FALSE, fig.align='center', fig.width=12}

# the vizParam() custom function helps us select some information to be plotted
visPutida <- vizParam("R3", putida)
visColi <- vizParam("R3", coli)

# here we prepare the plot with the distributions for P. putida
putida_plot <- distributionPlot(putidaSubset_tibble, threshold = 10^2, main = "*P. putida* KT2440", visParam = visPutida) +
  theme(axis.text.y.right = element_blank(),
        plot.margin = margin(t = 0, r = 10, b = 0, l = -10))

# here we prepare the plot with the distributions for E. coli
coli_plot <- distributionPlot(coliSubset_tibble, threshold = 10^2, main = "*E. coli* DH10B", visParam = visColi) +
  theme(axis.text.y.right = element_blank(),
        plot.margin = margin(t = 0, r = 10, b = 0, l = -10))

# As we will want to display both plots in the same figure, we generate below an "common y-axis" for them
text_labels <- putida$metadata %>%
  select(readableName) %>%
  unique() %>%
  ggplot(aes(label = readableName, y = readableName, x = 1)) +
  ggtext::geom_textbox(box.color = NA,
                       fill = NA,
                       position = position_nudge(y = 0.5, x = 0.5),
                       size = 5,
                       halign = 1) +
  scale_y_discrete(expand = expansion(add = c(0.2, 1)), limits = rev) +
  theme_void() +
  theme(
    plot.margin = margin(t = 50, r = -15, b = 50, l = -10),
    plot.background = element_rect(fill = "white", color = "white")
  )

# using ggarrange, we can display both plots and the custom y-axis on the same figure
ggpubr::ggarrange(text_labels, coli_plot, putida_plot, nrow = 1, widths = c(1.0, 1.9,1.9))


```
